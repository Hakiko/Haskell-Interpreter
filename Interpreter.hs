module Interpreter where

-- Haskell module generated by the BNF converter

import AbsCmm
import ErrM
import Debug.Trace
import qualified Exec as Exec
import qualified Data.Map.Strict as Map
import qualified Data.String
type Result = Exec.Scope -> Err Exec.Scope
type ResultLoc = Exec.Scope -> Err (Exec.Scope, Exec.Loc)

data AccessType = Member | PointerMember
data AccessData = AccessName String | AccessField String ResultLoc
data InstanceData = IBase Exec.Type String | IArray Exec.Type String Integer

extractMember acdat mems = \s -> 
  do
    (s, l) <- extractAccess acdat s
    foldl membFold (Ok (s, l)) mems
    where
      membFold (Bad s) _ = Bad s
      membFold (Ok (s, l)) (Member, (AccessName mn)) = Exec.getLocMember l mn s
      membFold (Ok (s, l)) (PointerMember, (AccessName mn)) =
        do
          lt <- Exec.getLocationType l s
          s <- case lt of (Exec.Pointer _) -> Ok s
                          _ -> Bad "Not a pointer."
          subl <- Exec.fetchPointer l s
          Exec.getLocMember subl mn s
      membFold (Ok (s, l)) (Member, (AccessField mn mlgen)) =
        do
          (s, ml) <- mlgen s
          (s, fl) <- Exec.getLocMember l mn s
          Exec.checkLocType ml (Exec.Builtin "int") s
          id <- Exec.fetchInt ml s
          lt <- Exec.getLocationType fl s
          case lt of 
            (Exec.Array _ size) ->
              do
                arr <- Exec.fetchArray fl s
                if id < 0 || id >= size then Bad "Index out of bounds." else Ok (s, arr !! id)
            _ -> Bad "Not and array."
      membFold (Ok (s, l)) (PointerMember, (AccessField mn mlgen)) =
        do
          plt <- Exec.getLocationType l s
          s <- case plt of (Exec.Pointer _) -> Ok s
                           _ -> Bad "Not a pointer."
          subl <- Exec.fetchPointer l s
          (s, ml) <- mlgen s
          (s, fl) <- Exec.getLocMember subl mn s
          Exec.checkLocType ml (Exec.Builtin "int") s
          id <- Exec.fetchInt ml s
          lt <- Exec.getLocationType fl s
          case lt of 
            (Exec.Array _ size) ->
              do
                arr <- Exec.fetchArray fl s
                if id < 0 || id >= size then Bad "Index out of bounds." else Ok (s, arr !! id)
            _ -> Bad "Not and array."

extractAccess (AccessName nm) = \s -> 
  do
    nm <- Exec.checkNameBound nm s
    l <- Exec.getFromName nm s
    Ok (s, l)

extractAccess (AccessField nm gen) = \s ->
  do
    (s, idl) <- gen s
    Exec.checkLocType idl (Exec.Builtin "int") s
    id <- Exec.fetchInt idl s
    l <- Exec.getFromName nm s
    lt <- Exec.getLocationType l s
    case lt of (Exec.Array _ size) ->
                  do
                    arr <- Exec.fetchArray l s
                    if id < 0 || id >= size then Bad "Index out of bounds." else Ok (s, arr !! id)
               _ -> Bad ("Not an array.")

exprsToLocs exprs s = foldl foldFunc (Ok (s, [])) exprs where
  foldFunc (Ok (s, a)) e = 
    do
      (s, l) <- transExpr e s
      Ok (s, a ++ [l])
  foldFunc (Bad s) _ = Bad s

callProcWithArgs l exprs = \s -> 
  do 
    (s, acc) <- exprsToLocs exprs s
    lt <- Exec.getLocationType l s
    largt <- case lt of (Exec.LambdaVoid argt) -> Ok argt
                        _ -> Bad "Not a procedure."
    acct <- Ok (map (\v -> Exec.getLocationType v s) acc)
    s <- if (map Ok largt) == acct then Ok s else Bad ("Argument type or length mismatch. Expected: " ++ (show largt) ++ "\nGot: " ++ (show acct))
    (proc, nmap) <- Exec.fetchProcedure l s
    --(s, h) <- Exec.globalLayer s
    nextMap <- Exec.getNameMap s
    s <- Exec.setNameMap nmap s
    s <- proc s acc
    s <- Exec.setNameMap nextMap s
    --s <- Exec.appendHistory h s
    Exec.clearRetVal s

callFuncWithArgs l exprs = \s -> 
  do 
    (s, acc) <- exprsToLocs exprs s
    lt <- Exec.getLocationType l s
    (largt, lrett) <- case lt of (Exec.Lambda rett argt) -> Ok (argt, rett)
                                 _ -> Bad "Not a function."
    acct <- Ok (map (\v -> Exec.getLocationType v s) acc)
    s <- if (map Ok largt) == acct then Ok s else Bad "Argument type or length mismatch."
    (proc, nmap) <- Exec.fetchFunction l s
    nextMap <- Exec.getNameMap s
    s <- Exec.setNameMap nmap s
    (s, rl) <- proc s acc
    s <- Exec.setNameMap nextMap s
    rlt <- Exec.checkLocType rl lrett s
    s <- Exec.clearRetVal s
    Ok (s, rl)

          
failure x = \ _ -> Bad ("Undefined case: " ++ show x)

modifyScope (Bad s) _ = Bad s
modifyScope (Ok s) f = if Exec.hasRetVal s then Ok s else f s

transIdent :: Ident -> String
transIdent x = case x of
  Ident string -> string
transProgram :: Program -> Result
transProgram x = case x of
  RProgram globals -> \scope -> foldl modifyScope (Ok scope) (map transGlobal globals)
transGlobal :: Global -> Result
transGlobal x = case x of
  RGlobalInstance instance_ -> \s -> (transInstance instance_) s
  RGlobalStruct ident instancebases -> \s ->
    do
      fm <- makeFieldMap (map transInstanceBase instancebases) (Map.empty)
      Exec.addUserDef (transIdent ident) fm s
      where
        makeFieldMap ((IBase t n):tfs) acc =
          do
            makeFieldMap tfs (Map.insert n t acc)
        makeFieldMap ((IArray t n c):tfs) acc =
          do
            makeFieldMap tfs (Map.insert n (Exec.Array t (fromInteger c)) acc)
        makeFieldMap [] acc = Ok acc
transInstanceBase :: InstanceBase -> InstanceData
transInstanceBase x = case x of
  RInstanceBaseDirect type_ ident -> IBase (transType type_) (transIdent ident)
  RInstanceBaseArray type_ ident integer -> IArray (transType type_) (transIdent ident) integer
transInstance :: Instance -> Result
transInstance x = case x of
  RInstanceBase instancebase -> \s ->
    do
      it <- Ok (transInstanceBase instancebase)
      _transInstance it s
      where
        _transInstance (IBase t n) s =
          do
            (s, l) <- Exec.popLocation s
            s <- Exec.tieLocName l n s
            Exec.addFromType l t s
        _transInstance (IArray t n c) s =
          do
            s <- if c < 0 then Bad "Negative array size." else Ok s
            (s, l) <- Exec.popLocation s
            s <- Exec.tieLocName l n s
            Exec.addArray l t (fromInteger c) s
  RInstanceInit type_ ident expr -> \s -> 
    do 
      (s, l) <- (transExpr expr) s
      Exec.checkLocType l (transType type_) s
      (s, nl) <- Exec.popLocation s
      s <- Exec.cloneLocation l nl s
      Exec.tieLocName nl (transIdent ident) s
transExpr :: Expr -> ResultLoc
transExpr x = case x of
  RExpressionCompare expr1 compareop expr2 -> \s ->
    do
      func <- Ok (transCompareOp compareop)
      (s, l1) <- transExpr expr1 s
      (s, l2) <- transExpr expr2 s
      lt <- Exec.getLocationType l1 s
      Exec.checkLocType l2 lt s
      (s, rl) <- Exec.popLocation s
      compVal <- compareLoc l1 l2 lt func s
      s <- Exec.addBool rl compVal s
      Ok (s, rl)
      where
        compareLoc l1 l2 (Exec.Builtin "double") func s = 
          do
            v1 <- Exec.fetchDouble l1 s
            v2 <- Exec.fetchDouble l2 s
            Ok (func (toRational v1) (toRational v2))
        compareLoc l1 l2 (Exec.Builtin "int") func s = 
          do
            v1 <- Exec.fetchInt l1 s
            v2 <- Exec.fetchInt l2 s
            Ok (func (toRational v1) (toRational v2))
        compareLoc l1 l2 (Exec.Builtin "string") func s = 
          do
            v1 <- Exec.fetchString l1 s
            v2 <- Exec.fetchString l2 s
            res <- if (func 1 1) && (not (func 1 2)) && (not (func 2 1)) then Ok (v1 == v2) else (if (not (func 1 1)) && (func 2 1) && (func 1 2) then Ok (v1 /= v2) else Bad "string can not be compared like that.")
            Ok res

  RExpressionPlus expr1 expr2 -> \s ->
    do
      (s, l1) <- transExpr expr1 s
      (s, l2) <- transExpr expr2 s
      lt <- Exec.getLocationType l1 s
      Exec.checkLocType l2 lt s
      (s, rl) <- Exec.popLocation s
      s <- finish l1 l2 rl lt s
      Ok (s, rl)
      where
        finish l1 l2 rl (Exec.Builtin "double") s = 
          do
            v1 <- Exec.fetchDouble l1 s
            v2 <- Exec.fetchDouble l2 s
            Exec.addDouble rl (v1 + v2) s
        finish l1 l2 rl (Exec.Builtin "int") s = 
          do
            v1 <- Exec.fetchInt l1 s
            v2 <- Exec.fetchInt l2 s
            Exec.addInt rl (v1 + v2) s
        finish l1 l2 rl (Exec.Builtin "string") s = 
          do
            v1 <- Exec.fetchString l1 s
            v2 <- Exec.fetchString l2 s
            Exec.addString rl (v1 ++ v2) s
  RExpressionSub expr1 expr2 -> \s ->
    do
      (s, l1) <- transExpr expr1 s
      (s, l2) <- transExpr expr2 s
      lt <- Exec.getLocationType l1 s
      Exec.checkLocType l2 lt s
      (s, rl) <- Exec.popLocation s
      s <- finish l1 l2 rl lt s
      Ok (s, rl)
      where
        finish l1 l2 rl (Exec.Builtin "double") s = 
          do
            v1 <- Exec.fetchDouble l1 s
            v2 <- Exec.fetchDouble l2 s
            Exec.addDouble rl (v1 - v2) s
        finish l1 l2 rl (Exec.Builtin "int") s = 
          do
            v1 <- Exec.fetchInt l1 s
            v2 <- Exec.fetchInt l2 s
            Exec.addInt rl (v1 - v2) s
  RExpressionMult expr1 expr2 -> \s ->
    do
      (s, l1) <- transExpr expr1 s
      (s, l2) <- transExpr expr2 s
      lt <- Exec.getLocationType l1 s
      Exec.checkLocType l2 lt s
      (s, rl) <- Exec.popLocation s
      s <- finish l1 l2 rl lt s
      Ok (s, rl)
      where
        finish l1 l2 rl (Exec.Builtin "double") s = 
          do
            v1 <- Exec.fetchDouble l1 s
            v2 <- Exec.fetchDouble l2 s
            Exec.addDouble rl (v1 * v2) s
        finish l1 l2 rl (Exec.Builtin "int") s = 
          do
            v1 <- Exec.fetchInt l1 s
            v2 <- Exec.fetchInt l2 s
            Exec.addInt rl (v1 * v2) s
  RExpressionDiv expr1 expr2 -> \s ->
    do
      (s, l1) <- transExpr expr1 s
      (s, l2) <- transExpr expr2 s
      lt <- Exec.getLocationType l1 s
      Exec.checkLocType l2 lt s
      (s, rl) <- Exec.popLocation s
      s <- finish l1 l2 rl lt s
      Ok (s, rl)
      where
        finish l1 l2 rl (Exec.Builtin "double") s = 
          do
            v1 <- Exec.fetchDouble l1 s
            v2 <- Exec.fetchDouble l2 s
            Exec.addDouble rl (v1 / v2) s
        finish l1 l2 rl (Exec.Builtin "int") s = 
          do
            v1 <- Exec.fetchInt l1 s
            v2 <- Exec.fetchInt l2 s
            Exec.addInt rl (v1 `div` v2) s
  RExpressionUnary unaryop expr -> \s ->
    do
      (s, l) <- transExpr expr s
      transUnaryOp unaryop l s
  RExpressionContantInt integer -> \s -> 
    do
      (s, l) <- Exec.popLocation s
      s <- Exec.addInt l (fromInteger integer) s
      Ok (s, l)
  RExpressionContantDouble double -> \s -> 
    do
      (s, l) <- Exec.popLocation s
      s <- Exec.addDouble l double s
      Ok (s, l)
  RExpressionContantChar char -> \s -> 
    do
      (s, l) <- Exec.popLocation s
      s <- Exec.addChar l char s
      Ok (s, l)
  RExpressionConstantBool boolean -> \s -> 
    do
      (s, l) <- Exec.popLocation s
      s <- Exec.addBool l (transBoolean boolean) s
      Ok (s, l)
  RExpressionConstantNull _ -> \s -> 
    do
      (s, l) <- Exec.popLocation s
      s <- Exec.addNull l s
      Ok (s, l)
  RExpressionContantString string -> \s -> 
    do
      (s, l) <- Exec.popLocation s
      s <- Exec.addString l string s
      Ok (s, l)
  RExpressionVariable access -> \s -> transAccess access s
  RExpressionCall access exprs -> \s ->
    do
      (s, l) <- transAccess access s
      callFuncWithArgs l exprs s
  RExpressionLambda lambda -> transLambda lambda
transBoolean :: Boolean -> Bool
transBoolean x = case x of
  RTrue -> True
  RFalse -> False
transNull :: Null -> ResultLoc
transNull x = case x of
  RNull -> \s -> 
    do
      (s, l) <- Exec.popLocation s
      s <- Exec.addNull l s
      Ok (s, l)
transCompareOp :: (Ord a) => CompareOp -> (a -> a -> Bool)
transCompareOp x = case x of
  RCompareOpGt -> (>)
  RCompareOpLt -> (<)
  RCompareOpGeq -> (>=)
  RCompareOpLeq -> (<=)
  RCompareEq -> (==)
  RCompareNeq -> \a b -> not (a == b)
transUnaryOp :: UnaryOp -> (Exec.Loc -> Exec.Scope -> Err (Exec.Scope, Exec.Loc))
transUnaryOp x = case x of
  RUnaryMinus -> \l s ->
    do 
      rt <- Exec.getLocationType l s
      case rt of (Exec.Builtin "int") ->
                    do
                      i <- Exec.fetchInt l s
                      (s, rl) <- Exec.popLocation s
                      s <- Exec.addInt rl (-i) s
                      Ok (s, rl)
                 (Exec.Builtin "double") ->
                    do
                      d <- Exec.fetchDouble l s
                      (s, rl) <- Exec.popLocation s
                      s <- Exec.addDouble rl (-d) s
                      Ok (s, rl)
  RUnaryDeref -> \l s ->
    do
      lt <- Exec.getLocationType l s
      case lt of (Exec.Pointer subt) ->
                    do
                      tgt <- Exec.fetchPointer l s
                      Exec.checkLocExists tgt s
                      Ok (s, tgt)
  RUnaryAddr -> \l s ->
    do 
      (s, rl) <- Exec.popLocation s
      s <- Exec.addPointer rl l s
      Ok (s, rl)
  RUnaryIncr -> \l s ->
    do 
      rt <- Exec.getLocationType l s
      case rt of (Exec.Builtin "int") ->
                    do
                      i <- Exec.fetchInt l s
                      (s, rl) <- Exec.popLocation s
                      s <- Exec.addInt rl (i + 1) s
                      Ok (s, rl)
                 (Exec.Builtin "double") ->
                    do
                      d <- Exec.fetchDouble l s
                      (s, rl) <- Exec.popLocation s
                      s <- Exec.addDouble rl (d + 1) s
                      Ok (s, rl)
  RUnaryDecr -> \l s ->
    do 
      rt <- Exec.getLocationType l s
      case rt of (Exec.Builtin "int") ->
                    do
                      i <- Exec.fetchInt l s
                      (s, rl) <- Exec.popLocation s
                      s <- Exec.addInt rl (i - 1) s
                      Ok (s, rl)
                 (Exec.Builtin "double") ->
                    do
                      d <- Exec.fetchDouble l s
                      (s, rl) <- Exec.popLocation s
                      s <- Exec.addDouble rl (d - 1) s
                      Ok (s, rl)
transLambda :: Lambda -> ResultLoc
transLambda x = case x of
  RLambda type_ argnames block -> \s ->
    do
      (s, l) <- Exec.popLocation s
      nmap <- Exec.getNameMap s
      s <- Exec.addFunction l procType procBody nmap s
      Ok (s, l)
      where
        retT = transType type_
        argTypes = map fst (map transArgName argnames)
        argNames = map snd (map transArgName argnames)
        procType = Exec.Lambda retT argTypes
        procBody s argl = 
          do
            s <- if (map Ok argTypes) == (map (\v -> Exec.getLocationType v s) argl) then Ok s else Bad "Argument type or length mismatch."
            s <- Exec.pushLayer s
            s <- tieArgs argNames argl s
            s <- transBlock block s
            rl <- Exec.getRetVal s
            Exec.checkLocType rl retT s
            s <- Exec.popLayer s
            Ok (s, rl)
            where
              tieArgs (nm:ns) (loc:ls) s = 
                do
                  (s, l) <- Exec.popLocation s
                  s <- Exec.cloneLocation loc l s
                  s <- Exec.tieLocName l nm s
                  tieArgs ns ls s
              tieArgs [] [] s = Ok s
  RLambdaVoid argnames block -> \s ->
    do
      (s, l) <- Exec.popLocation s
      nmap <- Exec.getNameMap s
      s <- Exec.addProcedure l procType procBody nmap s
      Ok (s, l)
      where
        argTypes = map fst (map transArgName argnames)
        argNames = map snd (map transArgName argnames)
        procType = Exec.LambdaVoid argTypes
        procBody s argl = 
          do
            s <- if (map Ok argTypes) == (map (\v -> Exec.getLocationType v s) argl) then Ok s else Bad "Argument type or length mismatch."
            s <- Exec.pushLayer s
            s <- tieArgs argNames argl s
            s <- transBlock block s
            Exec.popLayer s
            where
              tieArgs (nm:ns) (loc:ls) s = 
                do
                  (s, l) <- Exec.popLocation s
                  s <- Exec.cloneLocation loc l s
                  s <- Exec.tieLocName l nm s
                  tieArgs ns ls s
              tieArgs [] [] s = Ok s

transArgName :: ArgName -> (Exec.Type, String)
transArgName x = case x of
  RArgName type_ ident -> (transType type_, transIdent ident)
transBlock :: Block -> Result
transBlock x = case x of
  RBlock instructions -> \s -> 
    do
      s <- Exec.pushLayer s
      s <- foldl modifyScope (Ok s) (map transInstruction instructions)
      Exec.popLayer s
  RBlockEmpty -> Ok
transIdentOrArr :: IdentOrArr -> AccessData
transIdentOrArr x = case x of
  RIdentOrArrayId ident -> AccessName (transIdent ident)
  RIdentOrArrayArr ident expr -> AccessField (transIdent ident) (transExpr expr)
transAccess :: Access -> ResultLoc
transAccess x = case x of
  RAccess identorarr -> extractAccess (transIdentOrArr identorarr)
  RAccessMember identorarr members -> extractMember (transIdentOrArr identorarr) (map transMember members)
transMember :: Member -> (AccessType, AccessData)
transMember x = case x of
  RMember accessop identorarr -> (transAccessOp accessop, transIdentOrArr identorarr)
transAccessOp :: AccessOp -> AccessType
transAccessOp x = case x of
  RAccessMem -> Member
  RAccessPtr -> PointerMember
transLValue :: LValue -> ResultLoc
transLValue x = case x of
  RLValue access -> transAccess access
  RLvalueDeref lvalue -> \s ->
    do
      (s, l) <- transLValue lvalue s
      lt <- Exec.getLocationType l s
      case lt of (Exec.Pointer subt) ->
                    do
                      tgt <- Exec.fetchPointer l s
                      Exec.checkLocExists tgt s
                      Ok (s, tgt)
transInstruction :: Instruction -> Result
transInstruction x = case x of
  RInstructionReturn expr -> \s -> 
    do (s, l) <- transExpr expr s
       Exec.withRetVal l s
  RInstructionReturnVoid -> \s -> Exec.withRetVal (-1) s
  RInstructionBlock block -> transBlock block
  RInstructionInstance instance_ -> \s -> transInstance instance_ s
  RInstructionCall access exprs -> \s ->
    do
      (s, l) <- transAccess access s
      lt <- Exec.getLocationType l s
      case lt of Exec.LambdaVoid _ -> callProcWithArgs l exprs s
                 Exec.Lambda _ _ -> 
                  do 
                    (s, _) <- callFuncWithArgs l exprs s
                    Ok s
  RInstructionAssign lvalue expr -> \s ->
    do
      (s, l) <- transExpr expr s
      lt <- Exec.getLocationType l s
      (s, tl) <- transLValue lvalue s
      Exec.checkLocType tl lt s
      Exec.cloneLocation l tl s
  RInstructionIf expr block -> \s ->
    do
      (s, l) <- transExpr expr s
      Exec.checkLocType l (Exec.Builtin "bool") s
      bl <- Exec.fetchBool l s
      if bl then transBlock block s else Ok s
  RInstructionIfElse expr block1 block2 -> \s ->
    do
      (s, l) <- transExpr expr s
      Exec.checkLocType l (Exec.Builtin "bool") s
      bl <- Exec.fetchBool l s
      if bl then transBlock block1 s else transBlock block2 s
  RInstructionWhile expr block -> \s ->
    do loop expr block s
    where
      loop expr block s =
        do
          (s, l) <- transExpr expr s
          Exec.checkLocType l (Exec.Builtin "bool") s
          bl <- Exec.fetchBool l s
          if bl then transBlock block s >>= loop expr block else Ok s
transType :: Type -> Exec.Type
transType x = case x of
  RTypeBase ident -> if elem ts Exec.builtinTypes then Exec.Builtin ts else Exec.UserType ts where ts = transIdent ident
  RTypeLambda type_ types -> Exec.Lambda (transType type_) (map transType types)
  RTypeLambdaVoid types -> Exec.LambdaVoid (map transType types)
  RTypePointer type_ -> Exec.Pointer (transType type_)

